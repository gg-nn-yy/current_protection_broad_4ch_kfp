/*******************************************************************************
 * Modbus可以在各种介质上传输，它的传输报文类型支持三种：ASCII、RTU、TCP三种
 * 使用串口传输时可以选择RTU或ASCII模式，当然常用的就是RTU模式。
 
 *                               Modbus报文
 * Modbus报文是指主机发送给从机的一帧数据，其中包含着从机的地址，主机想执行的操
   作，校验码等内容，最大为256 字节：
	----------------------------------------------------------------------------
	|    从机地址    |    功能码    |        数据         |         CRC        |
	----------------------------------------------------------------------------
	|    1字节       |    1字节     |      0到252字节     |   2字节CRC低CRC高  |
	----------------------------------------------------------------------------
 * 从机地址:每个从机都有唯一地址(机没有地址)，占用一个字节，范围0-255，其中从机
   有效地址范围是1-247；
 * 功能码: 占用一个字节，功能码的意义是告诉从机这帧数据是干啥的，可以查询从机的
   数据，也可以修改从机的数据；
 * 数据: 根据功能码不同，对应不同内容，比如功能码是查询从机的数据，这里就包括要
   查询哪些数据和查询字节数等；
 * 校验: 在传输过程中数据坑会发生错误，CRC检验可以检测接收的数据是否正确。

 *  ----------------------------------------------------------------------------
	|                描述                 |               功能码               |
	----------------------------------------------------------------------------
	|            读多个寄存器             |                 03                 |
	----------------------------------------------------------------------------
	|            写单个寄存器             |                 06                 |
	----------------------------------------------------------------------------
	|            写多个寄存器             |                 16（0x10）         |
	----------------------------------------------------------------------------
   
 * 寄存器，可以理解为设备上的某一个控制项，比如传感器或者继电器，对应的需要在软
   件中为每一个寄存器分配码值，在Mdobus中叫做寄存器地址，并不是单片机片上外设的
   硬件寄存器。

 * 读多个寄存器：
   主机向从机发送数据：
	----------------------------------------------------------------------------
	|   1从机地址  |   2功能码   |   3寄存器地址高字节   |   4寄存器地址低字节 |
	----------------------------------------------------------------------------
	|     0x01     |    0x03     |         0x00          |        0x00         |
	----------------------------------------------------------------------------
	----------------------------------------------------------------------------
	|   5寄存器个数高字节   |   6寄存器个数低字节   | 7CRC低字节 |  8CRC高字节 |
	----------------------------------------------------------------------------
	|	      0x00          |         0x02          |            |             |
	----------------------------------------------------------------------------
   从机返回数据：
    ----------------------------------------------------------------------------
    | 1从机地址 | 2功能码 | 3应答字节数 | 4数据内容1高字节 |  5数据内容1低字节 |
    ----------------------------------------------------------------------------
    |   0x01    |  0x03   |    0x04     |      0x00        |       0x00        |
    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    |    6数据内容2高字节    |   7数据内容2低字节   | 8CRC低字节 |  9CRC高字节 |
    ----------------------------------------------------------------------------
    |          0x02          |                      |            |             |
    ----------------------------------------------------------------------------
   
   
 * 写单个寄存器：
   主机向从机发送数据：
    ----------------------------------------------------------------------------
    |   1从机地址   |   2功能码   |  3寄存器地址高字节  |   4寄存器地址低字节  |
    ----------------------------------------------------------------------------
    |      0x01     |    0x06     |        0x00         |         0x03         |
    ----------------------------------------------------------------------------
    ----------------------------------------------------------------------------
    |    5数据内容高字节    |    6数据内容低字节    | 7CRC低字节 |  8CRC高字节 |
    ----------------------------------------------------------------------------
    |         0x00          |         0x01          |            |             |
    ----------------------------------------------------------------------------
   从机返回数据：
	----------------------------------------------------------------------------
	|   1从机地址   |   2功能码   |  3寄存器地址高字节  |   4寄存器地址低字节  |
	----------------------------------------------------------------------------
	|     0x01      |    0x06     |        0x00         |         0x03         |
	----------------------------------------------------------------------------
	----------------------------------------------------------------------------
	|    5数据内容高字节    |    6数据内容低字节    | 7CRC低字节 |  8CRC高字节 |
	----------------------------------------------------------------------------
	|         0x00          |         0x01          |            |             |
	----------------------------------------------------------------------------
   
   
 * 写多个寄存器：
   主机向从机发送数据：
	----------------------------------------------------------------------------
	|   1从机地址   |   2功能码   | 3要写的寄存器起始地址 |  4要写的寄存器数量 |
	----------------------------------------------------------------------------
	|     0x01      |     0x10    |      0x00   0x02      |     0x00   0x02    |
	----------------------------------------------------------------------------
	----------------------------------------------------------------------------
	|   5后面跟的字节数   |    6要写入的寄存器值    | 7CRC低字节 |  8CRC高字节 |
	----------------------------------------------------------------------------
	|        0x04         | 0x00  0x01  0x00  0x01  |            |             |
	----------------------------------------------------------------------------
   从机返回数据：
	----------------------------------------------------------------------------
	|   1从机地址   | 2功能码 | 3已写入的寄存器起始地址 |  4已写入的寄存器数量 |
	----------------------------------------------------------------------------
	|     0x01      |   0x10  |      0x00   0x02        |       0x00 0x02      |
	----------------------------------------------------------------------------
	----------------------------------------------------------------------------
	|              7CRC低字节             |             8CRC高字节             |
	----------------------------------------------------------------------------
	|                                     |                                    |
	----------------------------------------------------------------------------
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */



/* ======================== 头文件 ========================================== */
#include <stdint.h>
#include <stdlib.h>

#include "modbus_slave.h"
#include "sensor_driver.h"
#include "led_driver.h"

#include "modbus_app.h"



/* ======================== 全局变量定义区 ================================== */
static void prvvModbusGetTemp(uint16_t *value);
static void prvvModbusGetHumi(uint16_t *value);
static void prvvModbusSetLed1(uint16_t value);
static void prvvModbusSetLed2(uint16_t value);

/* 寄存器实例数组                                                             */
static mb_register_instance_t g_reg_instance_array[] = 
{
	{	/* 温度 01 03 00 00 00 02                                             */
		.property = R,
		.address  = 0x0000,
		.readCb   = prvvModbusGetTemp,
	},
	{	/* 湿度 01 03 00 01 00 02                                             */
		.property = R,
		.address  = 0x0001,
		.readCb   = prvvModbusGetHumi,
	},
	{	/* LED1开/关 01 06 00 02 00 01/00
		   LED1 LED2 01 10 00 02 00 02 04 00 01 00 01                         */
		.property  = R | W,
		.address   = 0x0002,
		.min_value = 0,
		.max_value = 1,
		.writeCb   = prvvModbusSetLed1,
	},
	{	/* LED2开/关 01 06 00 03 00 01/00                                     */
		.property  = R | W,
		.address   = 0x0003,
		.min_value = 0,
		.max_value = 1,
		.writeCb   = prvvModbusSetLed2,
	},
};

#define REGISTER_TABLE_SIZE \
	(sizeof(g_reg_instance_array) / sizeof(g_reg_instance_array[0]))



/* ======================== 宏函数定义区 ==================================== */



/* ======================== 局部接口定义区 ================================== */
/*******************************************************************************
 * @brief  寄存器读应用回调函数，当接收到读命令时，modbus会自动调用此函数
 *
 * @param[in] start_address：起始寄存器地址,由modbus自动解析
 * @param[in] register_number：寄存器个数,由modbus自动解析
 * @param[out] pBuffer：数据内容,由modbus自动解析
 *
 * @return MB_EINVAL                                                    非法参数
 * @return MB_ENOREG                                              非法寄存器地址
 * @return MB_ENOERR                                                      无错误
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
static eMBErrorCode prvxReadRegistersCb( uint8_t start_address, 
	                                     uint8_t register_number,
                                         uint8_t *pBuffer                 )
{
	/* 1、检查参数                                                            */
	if ( NULL == pBuffer ) {
		return MB_EINVAL;
	}

	/* 2、解析数据                                                            */
	for ( uint32_t i = 0; i < register_number; i++ ) {
		mb_register_instance_t *instance = NULL;
		/* 2.1、解析每一项寄存器内容                                          */
		for ( uint32_t j = 0; j < REGISTER_TABLE_SIZE; j++ ) {
			/* 2.1.1、校验寄存器地址                                          */
			if ( (start_address + i) != g_reg_instance_array[j].address ) {
				continue;
			}
			
			/* 2.1.2、校验功能码                                              */
			instance = &g_reg_instance_array[j];
			if ( 0 == (instance->property & R )) {
				return MB_EINVAL;
			}
			
			/* 2.1.3、校验控制项实例,触发对应控制项                           */
			if ( NULL != instance->readCb ) {
				instance->readCb( (uint16_t *)&pBuffer[2 * i] );
			}
		} // end for
		
		/* 2.2、校验寄存器实例                                                */
		if ( NULL == instance ) {
			return MB_ENOREG;
		}
	} // end for
	
	return MB_ENOERR;
}


/*******************************************************************************
 * @brief  寄存器写应用回调函数，当接收到写命令时，modbus会自动调用此函数
 * 
 * @param[in] start_address：起始寄存器地址,由modbus自动解析
 * @param[in] register_number：寄存器个数,由modbus自动解析
 * @param[in] pBuffer：数据内容,由modbus自动解析
 * 
 * @return MB_EINVAL                                                    非法参数
 * @return MB_ENOREG                                              非法寄存器地址
 * @return MB_ENOERR                                                      无错误
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
static eMBErrorCode prvxWriteRegistersCb( uint8_t start_address,
	                                      uint8_t register_number,
	                                      uint8_t * pBuffer        )
{
	/* 1、检查参数                                                            */
	if ( NULL == pBuffer ) {
		return MB_EINVAL;
	}
	
	/* 2、解析数据                                                            */
	for ( uint32_t i = 0; i < register_number; i++ ) {
		
		mb_register_instance_t *instance = NULL;
		/* 2.1、解析每一项寄存器内容                                          */
		for ( uint32_t j = 0; j < REGISTER_TABLE_SIZE; j++ ) {
			
			/* 2.1.1、校验寄存器地址                                          */
			if ( (start_address + i) != g_reg_instance_array[j].address ) {
				continue;
			}
			
			/* 2.1.2、校验功能码                                              */
			instance = &g_reg_instance_array[j];
			if ( 0 == (instance->property & W) ) {
				return MB_EINVAL;
			}
			
			/* 2.1.3、校验写入数据                                            */
			uint16_t set_value = ( (pBuffer[2 * i] << 8) & 0xFF00 ) |
			                       (pBuffer[2 * i + 1] 	& 0xFF);
			if ( (set_value < instance->min_value) || 
				 (set_value > instance->max_value)    ) {
				return MB_EINVAL;		 
			 }
			
			/* 2.1.4、校验控制项实例,触发对应控制项                           */
			if ( NULL != instance->writeCb ) {
				instance->writeCb(set_value);
			}
		} // end for
		
		/* 2.2、校验寄存器实例                                                */
		if ( NULL == instance ) {
			return MB_ENOREG;
		}
	} // end for
	return MB_ENOERR;
}


/*******************************************************************************
 * @brief  寄存器控制项
 * 
 * @param  
 *
 * @return void
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
static void prvvModbusGetTemp(uint16_t *pValue)
{
	sensor_data_t sensor_data;
	vSensor_DataGet(&sensor_data);
	*pValue = (uint16_t)(sensor_data.temp * 10);
}

static void prvvModbusGetHumi(uint16_t *pValue)
{
	sensor_data_t sensor_data;
	vSensor_DataGet(&sensor_data);
	*pValue = (uint16_t)(sensor_data.humi * 10);
}

static void prvvModbusSetLed1(uint16_t value)
{
	0 == value ? vLed_TurnOff(LED1) : vLed_TurnOn(LED1);
}
	
static void prvvModbusSetLed2(uint16_t value)
{
	0 == value ? vLed_TurnOff(LED2) : vLed_TurnOn(LED2);
}



/* ======================== 对外接口定义区 ================================== */
/*******************************************************************************
 * @brief  modbus应用初始化，初始化modbus从机地址、波特率及读写应用回调函数
 * 
 * @param  void
 *
 * @return void
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void vModbus_AppInit(void)
{
	modbus_slave_instance_t mb_instance = {
		.slave_address              = 0x01,
		.baud_rate                  = 9600,
		.callback.pxRead_registers  = prvxReadRegistersCb,
		.callback.pxWrite_registers = prvxWriteRegistersCb,
	};
	
	vModbusSlaveInit(&mb_instance);
}


/*******************************************************************************
 * @brief  modbus任务，在主函数loop中周期性调用
 * 
 * @param  void
 *
 * @return void
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
void vModbus_Task(void)
{
	(void)eMBPoll();
}
